#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const NWS_API_BASE = "https://api.weather.gov";
const OPENWEATHER_API_BASE = "https://api.openweathermap.org/data/2.5";
const OPENWEATHER_API_KEY = process.env.OPENWEATHER_API_KEY || "2c68b7013a7c2143eb0a5a6845e41b85";
const USER_AGENT = "weather-app/1.0";

// ÂàõÂª∫ server instance
const server = new McpServer({
  name: "weather",
  version: "1.0.0",
  capabilities: {
    tools: {},
  },
});

// Helper function Áî®‰∫éÂèëÈÄÅ NWS API ËØ∑Ê±Ç
async function makeNWSRequest<T>(url: string): Promise<T | null> {
  const headers = {
    "User-Agent": USER_AGENT,
    Accept: "application/geo+json",
  };

  try {
    const response = await fetch(url, { headers });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return (await response.json()) as T;
  } catch (error) {
    console.error("Error making NWS request:", error);
    return null;
  }
}

// Helper function Áî®‰∫éÂèëÈÄÅ OpenWeatherMap API ËØ∑Ê±Ç
async function makeOpenWeatherRequest<T>(url: string): Promise<T | null> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return (await response.json()) as T;
  } catch (error) {
    console.error("Error making OpenWeather request:", error);
    return null;
  }
}

interface AlertFeature {
  properties: {
    event?: string;
    areaDesc?: string;
    severity?: string;
    status?: string;
    headline?: string;
  };
}

interface ForecastPeriod {
  name?: string;
  temperature?: number;
  temperatureUnit?: string;
  windSpeed?: string;
  windDirection?: string;
  shortForecast?: string;
}

interface AlertsResponse {
  features: AlertFeature[];
}

interface PointsResponse {
  properties: {
    forecast?: string;
  };
}

interface ForecastResponse {
  properties: {
    periods: ForecastPeriod[];
  };
}

// OpenWeatherMap API Á±ªÂûãÂÆö‰πâ
interface OpenWeatherCurrentResponse {
  name: string;
  sys: {
    country: string;
  };
  main: {
    temp: number;
    feels_like: number;
    temp_min: number;
    temp_max: number;
    pressure: number;
    humidity: number;
  };
  weather: Array<{
    main: string;
    description: string;
  }>;
  wind: {
    speed: number;
    deg: number;
  };
  visibility?: number;
  clouds: {
    all: number;
  };
}

interface OpenWeatherForecastResponse {
  city: {
    name: string;
    country: string;
  };
  list: Array<{
    dt: number;
    main: {
      temp: number;
      feels_like: number;
      temp_min: number;
      temp_max: number;
      humidity: number;
    };
    weather: Array<{
      main: string;
      description: string;
    }>;
    wind: {
      speed: number;
      deg: number;
    };
    dt_txt: string;
  }>;
}

// Ê†ºÂºèÂåñË≠¶Êä•Êï∞ÊçÆ
function formatAlert(feature: AlertFeature): string {
  const props = feature.properties;
  return [
    `Event: ${props.event || "Unknown"}`,
    `Area: ${props.areaDesc || "Unknown"}`,
    `Severity: ${props.severity || "Unknown"}`,
    `Status: ${props.status || "Unknown"}`,
    `Headline: ${props.headline || "No headline"}`,
    "---",
  ].join("\n");
}

// Ê†ºÂºèÂåñÈ£éÂêë
function getWindDirection(deg: number): string {
  const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
  return directions[Math.round(deg / 22.5) % 16];
}

// Ê≥®ÂÜåÂ§©Ê∞î tools
server.tool(
  "get-alerts",
  "Ëé∑ÂèñÊüê‰∏™Â∑ûÁöÑÂ§©Ê∞îË≠¶Êä•",
  {
    state: z.string().length(2).describe("‰∏§‰∏™Â≠óÊØçÁöÑÂ∑û‰ª£Á†ÅÔºà‰æãÂ¶Ç CA„ÄÅNYÔºâ"),
  },
  async ({ state }) => {
    const stateCode = state.toUpperCase();
    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;
    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);

    if (!alertsData) {
      return {
        content: [
          {
            type: "text",
            text: "Êú™ËÉΩÊ£ÄÁ¥¢Ë≠¶Êä•Êï∞ÊçÆ",
          },
        ],
      };
    }

    const features = alertsData.features || [];
    if (features.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: `No active alerts for ${stateCode}`,
          },
        ],
      };
    }

    const formattedAlerts = features.map(formatAlert);
    const alertsText = `Active alerts for ${stateCode}:\n\n${formattedAlerts.join(
      "\n"
    )}`;

    return {
      content: [
        {
          type: "text",
          text: alertsText,
        },
      ],
    };
  }
);

server.tool(
  "get-forecast",
  "Ëé∑ÂèñÊüê‰∏™‰ΩçÁΩÆÁöÑÂ§©Ê∞îÈ¢ÑÊä•",
  {
    latitude: z.number().min(-90).max(90).describe("‰ΩçÁΩÆÁöÑÁ∫¨Â∫¶"),
    longitude: z.number().min(-180).max(180).describe("‰ΩçÁΩÆÁöÑÁªèÂ∫¶"),
  },
  async ({ latitude, longitude }) => {
    // Ëé∑ÂèñÁΩëÊ†ºÁÇπÊï∞ÊçÆ
    const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(
      4
    )},${longitude.toFixed(4)}`;
    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);

    if (!pointsData) {
      return {
        content: [
          {
            type: "text",
            text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,
          },
        ],
      };
    }

    const forecastUrl = pointsData.properties?.forecast;
    if (!forecastUrl) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to get forecast URL from grid point data",
          },
        ],
      };
    }

    // Ëé∑ÂèñÈ¢ÑÊä•Êï∞ÊçÆ
    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);
    if (!forecastData) {
      return {
        content: [
          {
            type: "text",
            text: "Failed to retrieve forecast data",
          },
        ],
      };
    }

    const periods = forecastData.properties?.periods || [];
    if (periods.length === 0) {
      return {
        content: [
          {
            type: "text",
            text: "No forecast periods available",
          },
        ],
      };
    }

    // Ê†ºÂºèÂåñÈ¢ÑÊä• periods
    const formattedForecast = periods.map((period: ForecastPeriod) =>
      [
        `${period.name || "Unknown"}:`,
        `Temperature: ${period.temperature || "Unknown"}¬∞${
          period.temperatureUnit || "F"
        }`,
        `Wind: ${period.windSpeed || "Unknown"} ${period.windDirection || ""}`,
        `${period.shortForecast || "No forecast available"}`,
        "---",
      ].join("\n")
    );

    const forecastText = `Forecast for ${latitude}, ${longitude}:\n\n${formattedForecast.join(
      "\n"
    )}`;

    return {
      content: [
        {
          type: "text",
          text: forecastText,
        },
      ],
    };
  }
);

server.tool(
  "get-current-weather",
  "Ëé∑ÂèñÂÖ®ÁêÉ‰ªªÊÑèÂüéÂ∏ÇÁöÑÂΩìÂâçÂ§©Ê∞îÔºàÊîØÊåÅ‰∏≠ÂõΩÂüéÂ∏ÇÔºâ",
  {
    city: z.string().describe("ÂüéÂ∏ÇÂêçÁß∞ÔºåÂèØ‰ª•ÊòØ‰∏≠ÊñáÊàñËã±ÊñáÔºàÂ¶ÇÔºöÂåó‰∫¨„ÄÅBeijing„ÄÅ‰∏äÊµ∑„ÄÅShanghai„ÄÅNew YorkÁ≠âÔºâ"),
    country: z.string().optional().describe("ÂõΩÂÆ∂‰ª£Á†ÅÔºàÂèØÈÄâÔºåÂ¶ÇCNË°®Á§∫‰∏≠ÂõΩÔºåUSË°®Á§∫ÁæéÂõΩÔºâ"),
    units: z.enum(["metric", "imperial", "kelvin"]).default("metric").describe("Ê∏©Â∫¶Âçï‰ΩçÔºömetric(ÊëÑÊ∞èÂ∫¶)„ÄÅimperial(ÂçéÊ∞èÂ∫¶)„ÄÅkelvin(ÂºÄÂ∞îÊñá)"),
  },
  async ({ city, country, units }) => {
    let query = city;
    if (country) {
      query += `,${country}`;
    }
    
    const currentUrl = `${OPENWEATHER_API_BASE}/weather?q=${encodeURIComponent(query)}&appid=${OPENWEATHER_API_KEY}&units=${units}&lang=zh_cn`;
    const weatherData = await makeOpenWeatherRequest<OpenWeatherCurrentResponse>(currentUrl);

    if (!weatherData) {
      return {
        content: [
          {
            type: "text",
            text: `Êó†Ê≥ïËé∑Âèñ ${city} ÁöÑÂ§©Ê∞îÊï∞ÊçÆ„ÄÇËØ∑Ê£ÄÊü•ÂüéÂ∏ÇÂêçÁß∞ÊòØÂê¶Ê≠£Á°ÆÔºåÊàñÁ°Æ‰øùAPIÂØÜÈí•ÊúâÊïà„ÄÇ`,
          },
        ],
      };
    }

    const tempUnit = units === "metric" ? "¬∞C" : units === "imperial" ? "¬∞F" : "K";
    const windSpeedUnit = units === "metric" ? "m/s" : "mph";
    const windDir = weatherData.wind?.deg ? getWindDirection(weatherData.wind.deg) : "Êú™Áü•";

    const weatherText = [
      `üìç ${weatherData.name}, ${weatherData.sys.country}`,
      `üå°Ô∏è Ê∏©Â∫¶: ${Math.round(weatherData.main.temp)}${tempUnit} (‰ΩìÊÑü ${Math.round(weatherData.main.feels_like)}${tempUnit})`,
      `üå°Ô∏è Ê∏©Â∫¶ËåÉÂõ¥: ${Math.round(weatherData.main.temp_min)}${tempUnit} - ${Math.round(weatherData.main.temp_max)}${tempUnit}`,
      `‚òÅÔ∏è Â§©Ê∞î: ${weatherData.weather[0]?.description || "Êú™Áü•"}`,
      `üí® È£éÈÄü: ${weatherData.wind?.speed || 0} ${windSpeedUnit} ${windDir}`,
      `üíß ÊπøÂ∫¶: ${weatherData.main.humidity}%`,
      `üìä Ê∞îÂéã: ${weatherData.main.pressure} hPa`,
      weatherData.visibility ? `üëÅÔ∏è ËÉΩËßÅÂ∫¶: ${(weatherData.visibility / 1000).toFixed(1)} km` : "",
      `‚òÅÔ∏è ‰∫ëÈáè: ${weatherData.clouds.all}%`,
    ].filter(Boolean).join("\n");

    return {
      content: [
        {
          type: "text",
          text: weatherText,
        },
      ],
    };
  }
);

server.tool(
  "get-weather-forecast",
  "Ëé∑ÂèñÂÖ®ÁêÉ‰ªªÊÑèÂüéÂ∏ÇÁöÑ5Â§©Â§©Ê∞îÈ¢ÑÊä•ÔºàÊîØÊåÅ‰∏≠ÂõΩÂüéÂ∏ÇÔºâ",
  {
    city: z.string().describe("ÂüéÂ∏ÇÂêçÁß∞ÔºåÂèØ‰ª•ÊòØ‰∏≠ÊñáÊàñËã±ÊñáÔºàÂ¶ÇÔºöÂåó‰∫¨„ÄÅBeijing„ÄÅ‰∏äÊµ∑„ÄÅShanghai„ÄÅNew YorkÁ≠âÔºâ"),
    country: z.string().optional().describe("ÂõΩÂÆ∂‰ª£Á†ÅÔºàÂèØÈÄâÔºåÂ¶ÇCNË°®Á§∫‰∏≠ÂõΩÔºåUSË°®Á§∫ÁæéÂõΩÔºâ"),
    units: z.enum(["metric", "imperial", "kelvin"]).default("metric").describe("Ê∏©Â∫¶Âçï‰ΩçÔºömetric(ÊëÑÊ∞èÂ∫¶)„ÄÅimperial(ÂçéÊ∞èÂ∫¶)„ÄÅkelvin(ÂºÄÂ∞îÊñá)"),
  },
  async ({ city, country, units }) => {
    let query = city;
    if (country) {
      query += `,${country}`;
    }
    
    const forecastUrl = `${OPENWEATHER_API_BASE}/forecast?q=${encodeURIComponent(query)}&appid=${OPENWEATHER_API_KEY}&units=${units}&lang=zh_cn`;
    const forecastData = await makeOpenWeatherRequest<OpenWeatherForecastResponse>(forecastUrl);

    if (!forecastData) {
      return {
        content: [
          {
            type: "text",
            text: `Êó†Ê≥ïËé∑Âèñ ${city} ÁöÑÂ§©Ê∞îÈ¢ÑÊä•Êï∞ÊçÆ„ÄÇËØ∑Ê£ÄÊü•ÂüéÂ∏ÇÂêçÁß∞ÊòØÂê¶Ê≠£Á°ÆÔºåÊàñÁ°Æ‰øùAPIÂØÜÈí•ÊúâÊïà„ÄÇ`,
          },
        ],
      };
    }

    const tempUnit = units === "metric" ? "¬∞C" : units === "imperial" ? "¬∞F" : "K";
    const windSpeedUnit = units === "metric" ? "m/s" : "mph";

    // ÊåâÊó•ÊúüÂàÜÁªÑÈ¢ÑÊä•Êï∞ÊçÆ
    const dailyForecasts = new Map<string, typeof forecastData.list>();
    
    forecastData.list.forEach(item => {
      const date = item.dt_txt.split(' ')[0];
      if (!dailyForecasts.has(date)) {
        dailyForecasts.set(date, []);
      }
      dailyForecasts.get(date)!.push(item);
    });

    const formattedForecasts: string[] = [];
    
    for (const [date, dayData] of dailyForecasts) {
      const dayTemps = dayData.map(d => d.main.temp);
      const minTemp = Math.min(...dayTemps);
      const maxTemp = Math.max(...dayTemps);
      
      // ‰ΩøÁî®‰∏≠Âçà12ÁÇπÁöÑÊï∞ÊçÆ‰Ωú‰∏∫‰∏ªË¶ÅÂ§©Ê∞îÊèèËø∞
      const midDayData = dayData.find(d => d.dt_txt.includes('12:00:00')) || dayData[0];
      const windDir = midDayData.wind?.deg ? getWindDirection(midDayData.wind.deg) : "Êú™Áü•";
      
      const dateObj = new Date(date);
      const dateStr = dateObj.toLocaleDateString('zh-CN', { 
        month: 'long', 
        day: 'numeric',
        weekday: 'long'
      });

      formattedForecasts.push([
        `üìÖ ${dateStr}`,
        `üå°Ô∏è ${Math.round(minTemp)}${tempUnit} - ${Math.round(maxTemp)}${tempUnit}`,
        `‚òÅÔ∏è ${midDayData.weather[0]?.description || "Êú™Áü•"}`,
        `üí® ${midDayData.wind?.speed || 0} ${windSpeedUnit} ${windDir}`,
        `üíß ÊπøÂ∫¶: ${midDayData.main.humidity}%`,
        "---",
      ].join("\n"));
    }

    const forecastText = `üå§Ô∏è ${forecastData.city.name}, ${forecastData.city.country} 5Â§©Â§©Ê∞îÈ¢ÑÊä•Ôºö\n\n${formattedForecasts.join("\n")}`;

    return {
      content: [
        {
          type: "text",
          text: forecastText,
        },
      ],
    };
  }
);

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Global Weather MCP Server running on stdio");
  console.error("Supports US weather (NWS API) and worldwide weather (OpenWeatherMap API)");
  console.error("Tools available: get-alerts, get-forecast, get-current-weather, get-weather-forecast");
}

main().catch((error) => {
  console.error("Fatal error in main():", error);
  process.exit(1);
});
